# chunk greedy

0. **전처리 인덱싱**
	- 어떻게 할 것인가?
	- 링크드 리스트에 인덱스용 멤버변수를 하나 넣는다.
		long long으로 type을 지정한다.
	- 결국 정렬한다.
		- 어떻게 정렬할것인가?
		- 정렬하는 값과 인덱스를 서로 매칭시켜줘야한다.
		- 정렬하고서 그 값이 어떤 인덱스였는지 찾게하면 느리다.
		- 정렬하고나서 현재값의 최종 인덱스가 몇인지 알수 있게한다.
		- 연결리스트에 멤버변수로 넣은 값이 정렬되었을때 몇번 인덱스인지 어떻게 알게할 것인가?
		- 별도 자료공간에 다 정렬하고서
			연결리스트 값이 어디에 위치해있는지
			O(n**2)의 방법으로 알 수 있기는 하지만
			미리 정렬할때 구조체를 이용해서
			array에 특정값이 어떤 인덱스에 있는지를 저장한다.
			value =
			value_to_index =
		- 1. 정렬을 한다.
		- 2. 정렬 한 뒤에 해당 배열을 전부 순회하면서
			값마다 index가 어떻게되는지 저장한다.
			그럴려면 정수전체범위를 써야한다.
			메모리 낭비가 크다.
		- 3. 링크드 리스트에서 인덱스가 어떻게되는지 찾을때
				- bin search를 쓴다.
				- 의미가 있으려면 sorting도 n log n이어야한다.


1. **swap**
	- a: 스택 a에 있는 값을 모두 b로 넘긴다.
	- b: 스택 b에 있는 모든 값을 a로 넘깁니다.
	이떄 가장 큰값을 스택 top으로 올려서 큰 값부터 넘긴다.

	- **a. 세부 규칙**
		num의 값을 0이라 하고 chunk라는 상수가 15로 임의로 정한다.
		- chunk 값은 size에 비례해 효율의 값이 다르다
		- 최적의 chunk값은 직접 대입해서 구해볼 수 있다.

		- top의 값을 다음의 세 구간으로 구분하여 처리한다.
			1. top <= num
				b로 넘긴다.
				pb 1회
				num++
			2. num < top <= num + chunk
				b로 넘기고 넘긴값을 바닥으로 돌린다.
				pb 1회
				rb 1회
				num++
			3. num + chunk < top
				a의 맨 밑으로 넣는다.
				ra 1회
	- **b. 세부규칙**
		1. b의 가장 큰 값을 가장 효율적으로 top으로 옮긴다.
			- rr, r을 greedy하게 하라는 의미로 이해
		2. a로 넘긴다.
		3. b의 모든 값이 a로 넘길때까지 1,2를 반복한다.

	- __특정 값을 가장 효율적으로 top으로 옮기는 방법__
		1. 원하는 값이 전체 스택을 절반으로 나누고
		2. 상단에 존재하면 top이 될때까지 r(a/b)
		3. 하단에 존재하면 top될떄까지 rr(a/b)
