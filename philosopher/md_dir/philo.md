# 문제이해
- 철학자 문제
	- 공유자원이 있다(포크)
		- 5명이라 가정할때 테이블에 둘러앉는다.
		- 포크는 1인당 1개씩 주어진다.
		- 식사할떄 포크는 2개 필요하다
		- 포크는 내 앞에 있는 포크와 양옆에 있는 포크에서 선택가능하다.
		- 식사를 다하면 포크는 내려놓는다.
		- 그러면 다시 잔다.
		- 생각한다.
		- 다시 먹는다.
	- 입력값으로 철학자수, 못 먹으면 죽는시간, 먹는 시간, 자는시간, 최소한 먹어야하는 시간

	- 출력시간이 꼬여서는 안된다.
		- printf()특성을 이용해서
			- buffer에 차야지만 값이 출력되며
				그 기준은 "\n"이다.
			- 한번 printf()를 호출할때 다 출력한다.
	- 철학자가 한명이라도 죽으면 프로그램은 끝나야한다.
	- 일괄처리할것인가?
	- 뮤텍스의 의의는 무엇인가?
	- 무조건 막기만하면 효율적이지 못하다
		- 1개 스레드만 접근을 허용하게 할때의 문제
		- 그렇다면 동시에 여러 스레드가 접근가능하게 하면서도 데드락은 발생안하게하면 된다.
		- 데드락 탐지 회복조건은 못슨다.
			- 프로세스 종료가 안되므로.
			- 즉, 회피하거나 예방해야한다.

# 문제재정의

# 문제해결방법
- 공유자원
	- fork가 mutex이다.
	- progress lock 필요
		- 순서가 꼬이면 안되니까.
		- 어떤 철학자가 죽었는데 다른 철학자들이 다른 동작을 하면 안되므로
	- 철학자 구조체 내부에 lock이 필요한 경우가 있는가?
		- 필요없다고 생각
		- 내부에 공유자원은 없다.
- thread(철학자)별로 밥먹고, 자고, 생각하는 동작을 반복하게한다.
- 홀,짝으로 나눠서 식사한다.
- 홀수는 왼쪽부터 잡고 오른쪽을 잡는다.
- 짝소는 오른쪽을 잡고 왼쪽을 잡는다.

- 특정 동작을하면 그 동작을 출력하는 함수를 별도로 호출한다.
- thread들을 체크하는 thread를 만들어서 다 먹었는지 이제 못먹으면 죽는지 확인한다.
	- 먹기 직전에도 확인해야하는가?

- 추가 고려사항
	- 철학자 모두가 한번에 식탁에 앉은 상태에서 시작한다고 가정해야하는가?
	- hungry상태가 필요한가?
	- pickup(), putdown()상태도 필요한가?
		- 구현하기

- 홀짝별로 왼쪽, 오른쪽을 나눈다.

# TODO
- gettime
	시간을 규격에 맞게 표현한다.
	- usleep으로 했을때 안맞는 부분이 발생한다고 하는데 그 부분은 어디인가?
		어떻게 처리할 것인가?
- 구조체 멤버 구조 구성
	- status 구조체
		- 먹어야하는시간
		- 못 먹으면 죽는시간
		- 최소 먹어야하는 회수 등등
		- philosopher구조체
			- 현재상태를 기록하는 멤버변수가 필요한가?
				- 모니터를 쓸때 달라질 수 있다.
				- 모니터를 쓸때 어떤부분으로 확인할 것인가?
			- back number만 있어도 되지 않을까?
				- 이전까지 기록한 시간이 있어야한다.
					- 기록한 시간은 data type이 어떻게 되는가?
- 공유자원 처리기준
	- fork
		- 언제 포크를 잡을 것인가
		- 다른쪽이 잡고 있으면 어떻게 할 것인가?
		- 홀수 짝수 나눠서 처리한다.
			- 짝수를 sleep한다는 어떻게 하는가?
			- 딱 한번만 sleep한다.
			- process가 많아지면 지연될것이다.
			-
	- eating
	-
- 철학자 1명만 일때 기준

- 모니터 스레드
	- 무엇을 모니터할 것인가?
	- 제한시간내에 식사를 못해서 죽는 철학자(스레드)가 있는지
	- 모든 철학자가 정해진 횟수만큼 식사를 다 했는지
		-  만약 죽는 스레드 혹은 모든 스레드가 다 식사했다면
		다음 동작을 그만하게하고서 프로세스를 종료해야한다.
		- 그런데 다먹었는데도 다음 동작하는지는 어떻게 알 것인가?
		누가 마지막으로 다 먹은건지는 어떻게 체크할 것인가?
	- 일정 턴마다 확인한다?
		- 일정턴은 어떻게 정할것인가?
		- time to eat, sleep, time_to_die중에 작은 시간?
			- 아니면 3개 숫자의 공약수?
			- 공약수가 없다면?
		- 4 7 3
			1ms
		- 400 100 200
			100
			10 ms
			1500
			1595
		- 일정턴마다 확인해도 밀린다면?
		- 일정턴마다 확인하는 부분이 비효율적이라면?
		- 10ms까지 밀려서 출력은 괜찮으니까 그부분을 활용한다?
		- 죽은 후로부터 10ms이므로 일부 밀릴 수도 있는데 확인을 10ms로하면 문제가 될 수 있다.
	-


- 시간 출력
- 끝날때 어떻게 알릴 것인가?
- 우선 lock을 걸고 fork 드는 동작도 추가
	- 언제 포크를 들게 할것인가?

- 상태처리

12MAY22
- create()
	- pthread동작
	- odd, even group 쪼개기
		- routine 함수에서 처리
- monitor()
	- lock
	- 죽는것 확인
	- 다먹었는지 확인
- race condition check
- printf()

13MAY22 5:42
- deadlock 해결
	- print 뮤텍스는 전체 다 해서 1개밖에
- time function 정밀화
	- usleep을 쪼갠다.
		- 대기큐에서 대기하며 context switching이 소요되기 때문
- print function 분리
	- print lock 시점 고려
		- 어떻게해야 죽은 다음에 출력이 안되게 할 것인가?
		- 어떻게해야 mutex가 여러개인것으로 인해 실행이 지체되는 것을 줄이는 방식으로 구조화 할 수 있을것인가?
- monitor
	- routine function lock 재구조화
	- dead check
		- 죽었을때 다른 thread들이 더 이상 동작하지 못하게 한다.
	- full check

14MAY22 pm3:20
- print function 분리 √
	- print lock 시점 고려
		- 어떻게해야 죽은 다음에 출력이 안되게 할 것인가?
		- 어떻게해야 mutex가 여러개인것으로 인해 실행이 지체되는 것을 줄이는 방식으로 구조화 할 수 있을것인가?
- monitor -ing
	- routine function lock 재구조화
	- dead check
		- 죽었을때 다른 thread들이 더 이상 동작하지 못하게 한다.
	- full check
- time function 정밀화
	- usleep을 쪼갠다.
		- 대기큐에서 대기하며 context switching이 소요되기 때문
- error handling
	- 각 동작 실패했을때 free 및 destory


16MAY22 pm2:41

- time function 정확도 올리기  √
	- context switching 때문에 usleep을 적당히 쪼개서 하는게 기아방지를 할 수 있다.
		- usleep으로 자고 있을때
	-  usleep 함수를 시간 쪼개서 호출
- free and destory
	- mutex destory 이전에 어디까지 할당되었는지에 따라 변경됨
- 모니터 분리할지 고민
	- 분리안하는 경우
		- check full과 check die를 한개의 while문에서 처리한다.
			- 안그러면 check full, die를 나눠서 하기 때문에 스레드가 늘어날수록 부정확할 수 있다.
				- e.g)
					- check full 이후에 check die하는 경우
						철학자가 홀수이며 3번만 먹으면 죽게하는 경우
						마지막 철학자가 3번먹으면 끝나야하는데
						check ful하고서 check die를 하므로 그 사이에 철학자들이 식사를 진행해서 끝이 안날수도 있다.
						- 좀더 정확한 확인은 다먹은 철학자의 넘버를 찍을 수도 있다.
- 출력 색상입히기
- 에러테스트
	- 홀수 짝수
	- 시간인자값들 계속 변경하면서 테스트, 오래동안 살아남는지도 확인
	- 200명
	- leak 확인
	- data race 확인
		- mealtime mutex 제거하고서 해볼 것
	- 식사 다하고 죽는지
	- input값 일부러 음수나 경계값 넣기
	- 테스트용 코드 제거
	- 안쓰는 헤더 제거
	- 노미 맞추기

# 검증



# 실행



# 회고
